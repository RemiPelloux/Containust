//! Docker Compose YAML to `.ctst` converter.
//!
//! Parses a `docker-compose.yml` file and emits the equivalent
//! Containust `.ctst` composition language output.

use std::collections::BTreeMap;
use std::fmt::Write as FmtWrite;
use std::path::Path;

use serde::Deserialize;

/// Top-level docker-compose structure (subset we support).
#[derive(Debug, Deserialize)]
struct ComposeFile {
    #[serde(default)]
    services: BTreeMap<String, Service>,
}

/// A single docker-compose service definition.
#[derive(Debug, Deserialize)]
struct Service {
    image: Option<String>,
    #[serde(default)]
    ports: Vec<StringOrMapping>,
    #[serde(default)]
    volumes: Vec<String>,
    #[serde(default)]
    environment: EnvFormat,
    #[serde(default)]
    depends_on: DependsOnFormat,
    command: Option<CommandFormat>,
    entrypoint: Option<CommandFormat>,
    working_dir: Option<String>,
    user: Option<String>,
    hostname: Option<String>,
    #[serde(default)]
    restart: Option<String>,
    mem_limit: Option<String>,
    #[serde(alias = "deploy")]
    deploy: Option<Deploy>,
    healthcheck: Option<Healthcheck>,
    #[serde(default)]
    networks: Vec<String>,
    #[serde(default, rename = "read_only")]
    read_only: Option<bool>,
    build: Option<BuildConfig>,
}

/// Ports can be strings like "8080:80" or numbers.
#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum StringOrMapping {
    Simple(String),
    Number(u16),
}

/// Environment can be a map or a list of "KEY=VALUE" strings.
#[derive(Debug, Default, Deserialize)]
#[serde(untagged)]
enum EnvFormat {
    Map(BTreeMap<String, serde_yaml::Value>),
    List(Vec<String>),
    #[default]
    None,
}

/// `depends_on` can be a list of strings or a map with conditions.
#[derive(Debug, Default, Deserialize)]
#[serde(untagged)]
enum DependsOnFormat {
    List(Vec<String>),
    Map(BTreeMap<String, serde_yaml::Value>),
    #[default]
    None,
}

/// Command can be a string or a list.
#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum CommandFormat {
    String(String),
    List(Vec<String>),
}

/// Deploy section for resource limits.
#[derive(Debug, Deserialize)]
struct Deploy {
    resources: Option<Resources>,
}

/// Resource limits/reservations.
#[derive(Debug, Deserialize)]
struct Resources {
    limits: Option<ResourceSpec>,
}

/// Individual resource spec.
#[derive(Debug, Deserialize)]
struct ResourceSpec {
    memory: Option<String>,
    cpus: Option<String>,
}

/// Healthcheck configuration.
#[derive(Debug, Deserialize)]
struct Healthcheck {
    test: Option<HealthcheckTest>,
    interval: Option<String>,
    timeout: Option<String>,
    retries: Option<u32>,
    start_period: Option<String>,
}

/// Healthcheck test can be a string or list.
#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum HealthcheckTest {
    String(String),
    List(Vec<String>),
}

/// Build context.
#[derive(Debug, Deserialize)]
#[serde(untagged)]
enum BuildConfig {
    Simple(String),
    Extended(ExtendedBuild),
}

/// Extended build with context.
#[derive(Debug, Deserialize)]
struct ExtendedBuild {
    context: Option<String>,
}

/// Converts a docker-compose YAML file to `.ctst` format.
///
/// # Errors
///
/// Returns an error if the file cannot be read or parsed.
pub fn convert_file(path: &Path) -> anyhow::Result<String> {
    let content = std::fs::read_to_string(path)?;
    convert_string(&content)
}

/// Converts a docker-compose YAML string to `.ctst` format.
///
/// # Errors
///
/// Returns an error if the YAML cannot be parsed.
pub fn convert_string(yaml: &str) -> anyhow::Result<String> {
    let compose: ComposeFile = serde_yaml::from_str(yaml)?;
    let mut output = String::with_capacity(2048);

    write_header(&mut output, &compose);
    write_components(&mut output, &compose)?;
    write_connections(&mut output, &compose);

    Ok(output)
}

fn write_header(out: &mut String, compose: &ComposeFile) {
    out.push_str("// Auto-generated by: ctst convert\n");
    out.push_str("// Source: docker-compose.yml\n");
    let _ = writeln!(out, "// Components: {}", compose.services.len());
    out.push_str("//\n");
    out.push_str("// Review image sources â€” Docker Hub references have been converted\n");
    out.push_str("// to tar:// placeholders. Export images with:\n");
    out.push_str("//   docker save <image> -o /opt/images/<name>.tar\n\n");
}

fn write_components(out: &mut String, compose: &ComposeFile) -> anyhow::Result<()> {
    for (name, svc) in &compose.services {
        write_component(out, name, svc)?;
        out.push('\n');
    }
    Ok(())
}

fn write_component(out: &mut String, name: &str, svc: &Service) -> anyhow::Result<()> {
    let _ = writeln!(out, "COMPONENT {name} {{");

    write_image(out, svc);
    write_ports(out, svc);
    write_memory(out, svc);
    write_cpu(out, svc);
    write_env(out, svc);
    write_volumes(out, svc);
    write_command(out, "command", svc.command.as_ref());
    write_command(out, "entrypoint", svc.entrypoint.as_ref());
    write_readonly(out, svc);
    write_string_prop(out, "workdir", svc.working_dir.as_ref());
    write_string_prop(out, "user", svc.user.as_ref());
    write_string_prop(out, "hostname", svc.hostname.as_ref());
    write_restart(out, svc);
    write_network(out, svc);
    write_healthcheck(out, svc);

    out.push_str("}\n");
    Ok(())
}

fn write_image(out: &mut String, svc: &Service) {
    if let Some(ref image) = svc.image {
        let ctst_image = convert_image_ref(image);
        let _ = writeln!(out, "    image = \"{ctst_image}\"");
    } else if let Some(ref build) = svc.build {
        let ctx = match build {
            BuildConfig::Simple(s) => s.clone(),
            BuildConfig::Extended(e) => e.context.clone().unwrap_or_else(|| ".".into()),
        };
        let _ = writeln!(
            out,
            "    // TODO: run 'ctst build' on context directory, then reference the image"
        );
        let _ = writeln!(out, "    image = \"file://{ctx}\"");
    }
}

fn convert_image_ref(image: &str) -> String {
    if image.starts_with("file://") || image.starts_with("tar://") || image.starts_with("https://")
    {
        return image.to_string();
    }

    let base_name = image
        .split('/')
        .next_back()
        .unwrap_or(image)
        .split(':')
        .next()
        .unwrap_or(image);

    format!("tar:///opt/images/{base_name}.tar")
}

fn write_ports(out: &mut String, svc: &Service) {
    if svc.ports.is_empty() {
        return;
    }

    let parsed: Vec<(Option<u16>, u16)> = svc
        .ports
        .iter()
        .map(|p| match p {
            StringOrMapping::Simple(s) => parse_port_string(s),
            StringOrMapping::Number(n) => (None, *n),
        })
        .collect();

    if parsed.len() == 1 {
        let (host, container) = parsed[0];
        let _ = writeln!(out, "    port = {container}");
        if matches!(host, Some(h) if h != container) {
            let _ = writeln!(out, "    // EXPOSE {}:{container}", host.unwrap_or(0));
        }
    } else {
        let container_ports: Vec<String> = parsed.iter().map(|(_, c)| c.to_string()).collect();
        let _ = writeln!(out, "    ports = [{}]", container_ports.join(", "));
        for &(host, container) in &parsed {
            if matches!(host, Some(h) if h != container) {
                let _ = writeln!(out, "    // EXPOSE {}:{container}", host.unwrap_or(0));
            }
        }
    }
}

fn parse_port_string(s: &str) -> (Option<u16>, u16) {
    if let Some((host, container)) = s.split_once(':') {
        let host_port = host.parse::<u16>().unwrap_or(0);
        let container_port = container
            .split('/')
            .next()
            .and_then(|p| p.parse::<u16>().ok())
            .unwrap_or(0);
        (Some(host_port), container_port)
    } else {
        let port = s
            .split('/')
            .next()
            .and_then(|p| p.parse::<u16>().ok())
            .unwrap_or(0);
        (None, port)
    }
}

fn write_memory(out: &mut String, svc: &Service) {
    let mem = svc.mem_limit.as_deref().or_else(|| {
        svc.deploy
            .as_ref()
            .and_then(|d| d.resources.as_ref())
            .and_then(|r| r.limits.as_ref())
            .and_then(|l| l.memory.as_deref())
    });

    if let Some(m) = mem {
        let converted = convert_memory_notation(m);
        let _ = writeln!(out, "    memory = \"{converted}\"");
    }
}

fn convert_memory_notation(docker_mem: &str) -> String {
    let docker_mem = docker_mem.trim();
    if docker_mem.ends_with('m') || docker_mem.ends_with('M') {
        let num = &docker_mem[..docker_mem.len() - 1];
        return format!("{num}MiB");
    }
    if docker_mem.ends_with('g') || docker_mem.ends_with('G') {
        let num = &docker_mem[..docker_mem.len() - 1];
        return format!("{num}GiB");
    }
    if docker_mem.ends_with('k') || docker_mem.ends_with('K') {
        let num = &docker_mem[..docker_mem.len() - 1];
        return format!("{num}KiB");
    }
    docker_mem.to_string()
}

fn write_cpu(out: &mut String, svc: &Service) {
    let cpus = svc
        .deploy
        .as_ref()
        .and_then(|d| d.resources.as_ref())
        .and_then(|r| r.limits.as_ref())
        .and_then(|l| l.cpus.as_deref());

    if let Some(c) = cpus {
        if let Ok(val) = c.parse::<f64>() {
            #[allow(clippy::cast_possible_truncation, clippy::cast_sign_loss)]
            let shares = (val * 1024.0) as u64;
            let _ = writeln!(out, "    cpu = \"{shares}\"");
        }
    }
}

fn write_env(out: &mut String, svc: &Service) {
    let vars = collect_env_vars(&svc.environment);
    if vars.is_empty() {
        return;
    }

    out.push_str("    env = {\n");
    for (key, value) in &vars {
        if value.starts_with("${") && value.ends_with('}') {
            let inner = &value[2..value.len() - 1];
            let _ = writeln!(out, "        {key} = \"${{secret.{inner}}}\"");
        } else {
            let escaped = value.replace('\"', "\\\"");
            let _ = writeln!(out, "        {key} = \"{escaped}\"");
        }
    }
    out.push_str("    }\n");
}

fn collect_env_vars(env: &EnvFormat) -> Vec<(String, String)> {
    match env {
        EnvFormat::Map(m) => m
            .iter()
            .map(|(k, v)| {
                let val = match v {
                    serde_yaml::Value::String(s) => s.clone(),
                    serde_yaml::Value::Number(n) => n.to_string(),
                    serde_yaml::Value::Bool(b) => b.to_string(),
                    serde_yaml::Value::Null => String::new(),
                    other => format!("{other:?}"),
                };
                (k.clone(), val)
            })
            .collect(),
        EnvFormat::List(list) => list
            .iter()
            .filter_map(|entry| {
                let (k, v) = entry.split_once('=')?;
                Some((k.to_string(), v.to_string()))
            })
            .collect(),
        EnvFormat::None => Vec::new(),
    }
}

fn write_volumes(out: &mut String, svc: &Service) {
    if svc.volumes.is_empty() {
        return;
    }

    if svc.volumes.len() == 1 {
        let _ = writeln!(out, "    volume = \"{}\"", svc.volumes[0]);
    } else {
        let quoted: Vec<String> = svc.volumes.iter().map(|v| format!("\"{v}\"")).collect();
        let _ = writeln!(out, "    volumes = [{}]", quoted.join(", "));
    }
}

fn write_command(out: &mut String, prop: &str, cmd: Option<&CommandFormat>) {
    let Some(cmd) = cmd else { return };

    match cmd {
        CommandFormat::String(s) => {
            let parts: Vec<&str> = s.split_whitespace().collect();
            let quoted: Vec<String> = parts.iter().map(|p| format!("\"{p}\"")).collect();
            let _ = writeln!(out, "    {prop} = [{}]", quoted.join(", "));
        }
        CommandFormat::List(list) => {
            let quoted: Vec<String> = list.iter().map(|p| format!("\"{p}\"")).collect();
            let _ = writeln!(out, "    {prop} = [{}]", quoted.join(", "));
        }
    }
}

fn write_readonly(out: &mut String, svc: &Service) {
    if let Some(ro) = svc.read_only {
        let _ = writeln!(out, "    readonly = {ro}");
    }
}

fn write_string_prop(out: &mut String, prop: &str, value: Option<&String>) {
    if let Some(v) = value {
        let _ = writeln!(out, "    {prop} = \"{v}\"");
    }
}

fn write_restart(out: &mut String, svc: &Service) {
    let Some(ref restart) = svc.restart else {
        return;
    };

    let policy = match restart.as_str() {
        "no" | "never" => "never",
        "on-failure" => "on-failure",
        "always" | "unless-stopped" => "always",
        _ => return,
    };
    let _ = writeln!(out, "    restart = \"{policy}\"");
}

fn write_network(out: &mut String, svc: &Service) {
    if svc.networks.len() == 1 {
        let _ = writeln!(out, "    network = \"{}\"", svc.networks[0]);
    }
}

fn write_healthcheck(out: &mut String, svc: &Service) {
    let Some(ref hc) = svc.healthcheck else {
        return;
    };

    out.push_str("    healthcheck = {\n");

    if let Some(ref test) = hc.test {
        match test {
            HealthcheckTest::String(s) => {
                let _ = writeln!(out, "        command = [\"{s}\"]");
            }
            HealthcheckTest::List(list) => {
                let filtered: Vec<&String> = list
                    .iter()
                    .filter(|s| *s != "CMD" && *s != "CMD-SHELL")
                    .collect();
                let quoted: Vec<String> = filtered.iter().map(|p| format!("\"{p}\"")).collect();
                let _ = writeln!(out, "        command = [{}]", quoted.join(", "));
            }
        }
    }

    if let Some(ref interval) = hc.interval {
        let _ = writeln!(out, "        interval = \"{}\"", convert_duration(interval));
    }
    if let Some(ref timeout) = hc.timeout {
        let _ = writeln!(out, "        timeout = \"{}\"", convert_duration(timeout));
    }
    if let Some(retries) = hc.retries {
        let _ = writeln!(out, "        retries = {retries}");
    }
    if let Some(ref start) = hc.start_period {
        let _ = writeln!(
            out,
            "        start_period = \"{}\"",
            convert_duration(start)
        );
    }

    out.push_str("    }\n");
}

fn convert_duration(docker_dur: &str) -> String {
    let docker_dur = docker_dur.trim();
    if docker_dur.ends_with('s') || docker_dur.ends_with('m') || docker_dur.ends_with('h') {
        return docker_dur.to_string();
    }
    docker_dur.to_string()
}

fn write_connections(out: &mut String, compose: &ComposeFile) {
    let mut connections = Vec::new();

    for (name, svc) in &compose.services {
        let deps = match &svc.depends_on {
            DependsOnFormat::List(list) => list.clone(),
            DependsOnFormat::Map(map) => map.keys().cloned().collect(),
            DependsOnFormat::None => Vec::new(),
        };

        for dep in deps {
            connections.push((name.clone(), dep));
        }
    }

    if connections.is_empty() {
        return;
    }

    out.push_str("// Dependencies (converted from depends_on).\n");
    out.push_str("// CONNECT auto-injects _HOST, _PORT, _CONNECTION_STRING env vars.\n");
    for (source, target) in &connections {
        let _ = writeln!(out, "CONNECT {source} -> {target}");
    }
}

#[cfg(test)]
#[allow(clippy::expect_used)]
mod tests {
    use super::*;

    #[test]
    fn test_convert_simple_compose() {
        let yaml = r#"
services:
  web:
    image: nginx:1.25
    ports:
      - "8080:80"
    volumes:
      - ./html:/usr/share/nginx/html
    restart: always
  db:
    image: postgres:16
    environment:
      POSTGRES_DB: mydb
      POSTGRES_USER: user
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    volumes:
      - pgdata:/var/lib/postgresql/data
    ports:
      - "5432:5432"
"#;
        let result = convert_string(yaml).expect("conversion should succeed");

        assert!(result.contains("COMPONENT db {"));
        assert!(result.contains("COMPONENT web {"));
        assert!(result.contains("tar:///opt/images/nginx.tar"));
        assert!(result.contains("tar:///opt/images/postgres.tar"));
        assert!(result.contains("restart = \"always\""));
        assert!(result.contains("port = 80"));
        assert!(result.contains("port = 5432"));
    }

    #[test]
    fn test_convert_with_depends_on() {
        let yaml = r"
services:
  api:
    image: myapi:latest
    depends_on:
      - db
      - cache
  db:
    image: postgres:16
  cache:
    image: redis:7
";
        let result = convert_string(yaml).expect("conversion should succeed");

        assert!(result.contains("CONNECT api -> db"));
        assert!(result.contains("CONNECT api -> cache"));
    }

    #[test]
    fn test_convert_image_ref() {
        assert_eq!(
            convert_image_ref("nginx:1.25"),
            "tar:///opt/images/nginx.tar"
        );
        assert_eq!(
            convert_image_ref("library/postgres:16"),
            "tar:///opt/images/postgres.tar"
        );
        assert_eq!(
            convert_image_ref("file:///opt/myimage"),
            "file:///opt/myimage"
        );
    }

    #[test]
    fn test_convert_memory_notation() {
        assert_eq!(convert_memory_notation("512m"), "512MiB");
        assert_eq!(convert_memory_notation("1G"), "1GiB");
        assert_eq!(convert_memory_notation("256M"), "256MiB");
    }

    #[test]
    fn test_convert_with_healthcheck() {
        let yaml = r#"
services:
  web:
    image: nginx
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost/"]
      interval: 30s
      timeout: 10s
      retries: 3
"#;
        let result = convert_string(yaml).expect("conversion should succeed");

        assert!(result.contains("healthcheck = {"));
        assert!(result.contains("\"curl\""));
        assert!(result.contains("interval = \"30s\""));
        assert!(result.contains("retries = 3"));
    }

    #[test]
    fn test_convert_env_list_format() {
        let yaml = r"
services:
  app:
    image: myapp
    environment:
      - PORT=8080
      - DEBUG=true
";
        let result = convert_string(yaml).expect("conversion should succeed");

        assert!(result.contains("PORT = \"8080\""));
        assert!(result.contains("DEBUG = \"true\""));
    }
}
